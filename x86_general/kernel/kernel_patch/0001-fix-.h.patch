From ea7304f458a69c27b4098e3f0d04910995f1835f Mon Sep 17 00:00:00 2001
From: diemit <598757652@qq.com>
Date: Sat, 17 May 2025 10:19:15 +0800
Subject: [PATCH] fix h

Change-Id: If813dc3b8e5d4d50099be5f332928c8bd482551d
---
 include/linux/hyperhold_inf.h | 23 +++++++++++
 include/linux/memcg_policy.h  | 47 +++++++++++++++++++++
 include/linux/mm_purgeable.h  | 77 +++++++++++++++++++++++++++++++++++
 include/linux/reclaim_acct.h  | 48 ++++++++++++++++++++++
 include/linux/xpm_types.h     | 21 ++++++++++
 include/linux/zswapd.h        | 50 +++++++++++++++++++++++
 6 files changed, 266 insertions(+)
 create mode 100644 include/linux/hyperhold_inf.h
 create mode 100644 include/linux/memcg_policy.h
 create mode 100644 include/linux/mm_purgeable.h
 create mode 100644 include/linux/reclaim_acct.h
 create mode 100644 include/linux/xpm_types.h
 create mode 100644 include/linux/zswapd.h

diff --git a/include/linux/hyperhold_inf.h b/include/linux/hyperhold_inf.h
new file mode 100644
index 000000000..7d2bd1e88
--- /dev/null
+++ b/include/linux/hyperhold_inf.h
@@ -0,0 +1,23 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * include/linux/hyperhold_inf.h
+ *
+ * Copyright (c) 2020-2022 Huawei Technologies Co., Ltd.
+ */
+
+#ifndef HYPERHOLD_INF_H
+#define HYPERHOLD_INF_H
+
+#ifdef CONFIG_HYPERHOLD
+
+extern bool is_hyperhold_enable(void);
+
+#else
+
+static inline is_hyperhold_enable(void)
+{
+	return false;
+}
+#endif
+
+#endif
diff --git a/include/linux/memcg_policy.h b/include/linux/memcg_policy.h
new file mode 100644
index 000000000..4aec2a1bb
--- /dev/null
+++ b/include/linux/memcg_policy.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * include/linux/memcg_policy.h
+ *
+ * Copyright (c) 2020-2022 Huawei Technologies Co., Ltd.
+ *
+ */
+#ifndef _MEMCG_POLICY_H
+#define _MEMCG_POLICY_H
+
+struct mem_cgroup;
+struct pglist_data;
+struct scan_control;
+
+
+extern struct list_head score_head;
+extern bool score_head_inited;
+extern rwlock_t score_list_lock;
+extern struct cgroup_subsys memory_cgrp_subsys;
+#ifdef CONFIG_HYPERHOLD_FILE_LRU
+void shrink_anon_memcg(struct pglist_data *pgdat,
+		struct mem_cgroup *memcg, struct scan_control *sc,
+		unsigned long *nr);
+bool shrink_node_hyperhold(struct pglist_data *pgdat, struct scan_control *sc);
+#endif /* CONFIG_HYPERHOLD_FILE_LRU */
+
+#ifdef CONFIG_HYPERHOLD_MEMCG
+struct mem_cgroup *get_next_memcg(struct mem_cgroup *prev);
+void get_next_memcg_break(struct mem_cgroup *memcg);
+void memcg_app_score_update(struct mem_cgroup *target);
+
+struct memcg_reclaim {
+	atomic64_t app_score;
+	atomic64_t ub_ufs2zram_ratio;
+#ifdef CONFIG_HYPERHOLD_ZSWAPD
+	atomic_t ub_zram2ufs_ratio;
+	atomic_t ub_mem2zram_ratio;
+	atomic_t refault_threshold;
+	/* anon refault */
+	unsigned long long reclaimed_pagefault;
+#endif
+};
+#define MAX_APP_SCORE 1000
+#endif
+
+
+#endif /* _LINUX_MEMCG_POLICY_H */
diff --git a/include/linux/mm_purgeable.h b/include/linux/mm_purgeable.h
new file mode 100644
index 000000000..04d027cb1
--- /dev/null
+++ b/include/linux/mm_purgeable.h
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ */
+
+#ifndef __MM_PURGEABLE_MEM_H
+#define __MM_PURGEABLE_MEM_H
+
+#ifdef CONFIG_MEM_PURGEABLE
+
+void mm_init_uxpgd(struct mm_struct *mm);
+void mm_clear_uxpgd(struct mm_struct *mm);
+bool lock_uxpte(struct vm_area_struct *vma, unsigned long addr);
+void unlock_uxpte(struct vm_area_struct *vma, unsigned long addr);
+vm_fault_t do_uxpte_page_fault(struct vm_fault *vmf, pte_t *entry);
+bool uxpte_set_present(struct vm_area_struct *vma, unsigned long addr);
+void uxpte_clear_present(struct vm_area_struct *vma, unsigned long addr);
+
+/*
+ * mm_purg_pages_info: get purgeable pages count of @mm
+ * @mm:	[in]	pointer to mm
+ * @total_purg_pages:	[out]	total purgeable pages of @mm
+ * @pined_purg_pages:	[out]	pined purgeable pages of @mm
+ * If @mm is NULL, return with doing nothing.
+ * If @total_purg_pages and @pined_purg_pages are both NULL, return with doing nothing.
+ * If one of @total_purg_pages and @pined_purg_pages is NULL, other one will be counted.
+ */
+void mm_purg_pages_info(struct mm_struct *mm, unsigned long *total_purg_pages,
+	unsigned long *pined_purg_pages);
+
+/*
+ * purg_pages_info: get global purgeable pages in system
+ * @total_purg_pages:	[out]	total purgeable pages in system
+ * @pined_purg_pages:	[out]	pined purgeable pages in system
+ * If @total_purg_pages and @pined_purg_pages are both NULL, return with doing nothing.
+ * If one of @total_purg_pages and @pined_purg_pages is NULL, other one will be counted.
+ */
+void purg_pages_info(unsigned long *total_purg_pages, unsigned long *pined_purg_pages);
+
+#else /* CONFIG_MEM_PURGEABLE */
+
+static inline void mm_init_uxpgd(struct mm_struct *mm) {}
+
+static inline void mm_clear_uxpgd(struct mm_struct *mm) {}
+
+static inline bool lock_uxpte(struct vm_area_struct *vma,
+	unsigned long addr)
+{
+	return false;
+}
+
+static inline void unlock_uxpte(struct vm_area_struct *vma,
+	unsigned long addr) {}
+
+static inline vm_fault_t do_uxpte_page_fault(struct vm_fault *vmf,
+	pte_t *entry)
+{
+	return 0;
+}
+
+static inline bool uxpte_set_present(struct vm_area_struct *vma,
+	unsigned long addr)
+{
+	return false;
+}
+
+static inline void uxpte_clear_present(struct vm_area_struct *vma,
+	unsigned long addr) {}
+
+static inline void mm_purg_pages_info(struct mm_struct *mm,
+	unsigned long *total_purg_pages, unsigned long *pined_purg_pages) {}
+
+static inline void purg_pages_info(unsigned long *total_purg_pages,
+	unsigned long *pined_purg_pages) {}
+#endif /* CONFIG_MEM_PURGEABLE */
+#endif /* __MM_PURGEABLE_MEM_H */
+
diff --git a/include/linux/reclaim_acct.h b/include/linux/reclaim_acct.h
new file mode 100644
index 000000000..5cf26f326
--- /dev/null
+++ b/include/linux/reclaim_acct.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * include/linux/reclaim_acct.h
+ *
+ * Copyright (c) 2022 Huawei Technologies Co., Ltd.
+ */
+
+#ifndef _RECLAIM_ACCT_H
+#define _RECLAIM_ACCT_H
+
+#include <linux/sched.h>
+#include <linux/shrinker.h>
+
+/* RA is the abbreviation of reclaim accouting */
+enum reclaimacct_stubs {
+	RA_RECLAIM = 0,
+	RA_DRAINALLPAGES,
+	RA_SHRINKFILE,
+	RA_SHRINKANON,
+	RA_SHRINKSLAB,
+	NR_RA_STUBS
+};
+
+enum reclaim_type {
+	DIRECT_RECLAIMS = 0,
+	KSWAPD_RECLAIM,
+	ZSWAPD_RECLAIM,
+	RECLAIM_TYPES
+};
+
+#ifdef CONFIG_RECLAIM_ACCT
+static inline bool is_system_reclaim(enum reclaim_type type)
+{
+	return (type == KSWAPD_RECLAIM || type == ZSWAPD_RECLAIM);
+}
+
+void reclaimacct_tsk_init(struct task_struct *tsk);
+void reclaimacct_init(void);
+
+void reclaimacct_start(enum reclaim_type type, struct reclaim_acct *ra);
+void reclaimacct_end(enum reclaim_type type);
+
+void reclaimacct_substage_start(enum reclaimacct_stubs stub);
+void reclaimacct_substage_end(enum reclaimacct_stubs stub, unsigned long freed,
+				const struct shrinker *shrinker);
+#endif
+
+#endif /* _RECLAIM_ACCT_H */
diff --git a/include/linux/xpm_types.h b/include/linux/xpm_types.h
new file mode 100644
index 000000000..e8a0cec98
--- /dev/null
+++ b/include/linux/xpm_types.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ */
+
+#ifndef _XPM_TYPES_H
+#define _XPM_TYPES_H
+
+#include <linux/types.h>
+
+struct xpm_region {
+	unsigned long addr_start; /* start adress of xpm region */
+	unsigned long addr_end;   /* end address of xpm region */
+};
+
+struct cs_info {
+	uint32_t id_type;
+	uint32_t ownerid;
+};
+
+#endif /* _XPM_TYPES_H */
\ No newline at end of file
diff --git a/include/linux/zswapd.h b/include/linux/zswapd.h
new file mode 100644
index 000000000..3a9768a35
--- /dev/null
+++ b/include/linux/zswapd.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * include/linux/zswapd.h
+ *
+ * Copyright (c) 2020-2022 Huawei Technologies Co., Ltd.
+ */
+
+#ifndef _ZSWAPD_H
+#define _ZSWAPD_H
+
+enum {
+	CACHE_SIZE,
+	SWAP_SIZE,
+	CACHE_PAGE,
+	SWAP_PAGE,
+	CACHE_FAULT,
+	SWAP_FAULT,
+	READ_SIZE,
+	WRITE_SIZE,
+};
+
+struct group_swap_ops {
+	u64 (*group_read)(u16 gid, u64 req_size, void *priv);
+	u64 (*group_write)(u16 gid, u64 req_size, void *priv);
+	u64 (*group_data_size)(u16 gid, int type, void *priv);
+};
+
+struct group_swap_device {
+	void *priv;
+	struct group_swap_ops *ops;
+	struct list_head list;
+};
+
+#ifdef CONFIG_HYPERHOLD_ZSWAPD
+extern int zswapd_run(int nid);
+extern void zswapd_stop(int nid);
+extern void zswapd_status_show(struct seq_file *m);
+extern void wake_all_zswapd(void);
+extern void set_snapshotd_init_flag(unsigned int val);
+extern pid_t get_zswapd_pid(void);
+extern unsigned long long get_free_swap_threshold(void);
+extern struct group_swap_device *register_group_swap(struct group_swap_ops *ops, void *priv);
+extern void unregister_group_swap(struct group_swap_device *gsdev);
+
+#ifdef CONFIG_HYPERHOLD_DEBUG
+extern void memcg_eswap_info_show(struct seq_file *m);
+#endif
+#endif
+
+#endif /* _LINUX_ZSWAPD_H */
-- 
2.25.1

